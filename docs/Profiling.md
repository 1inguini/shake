# Profiling and optimisation

This page discusses how to profile and optimise a Shake-based build system. In general there are two extremes of build system performance - when nothing has changed (also known as the zero build), and when everything has changed or when building from scratch (the full build). By optimising both extremes, and ensuring dependencies are minimal, we typically ensure good performance everywhere.

Before doing any performance investigation, make sure you are passing a suitable parallelism flag (`-j` to automatically determine parallelism, `-j8` for 8 threads). Note also that Shake uses random scheduling, which offers a significant speedup by avoiding worst-case behaviour, but does make reproducing numbers harder than it would otherwise be.

Shake features a number of different profiling tools, each capable of investigating different aspects of performance, which we now discuss.

## Console profile reports

The simplest way to view the performance of a build is to pass `--profile=-` which prints a minimal profile report to the console, for example:

<pre>
<!-- nosyntax -->* This database has tracked 7 runs.
* There are 466 rules (146 rebuilt in the last run).
* Building required 56 traced commands (23 in the last run).
* The total (unparallelised) time is 4m53s of which 4m43s is traced commands.
* The longest rule takes 10.3s (Development/Make/Rules.o),
  and the longest traced command takes 10.1s (ghc).
* Last run gave an average parallelism of 3.12 times over 1m05s.
</pre>

To see the report for the previous run pass `--no-build`.

This provides a subset of the information generated by the (HTML profile reports)[#html-profile]. It lets you see the parallelism etc.

## Timing information

The next step is to run `--timing`, which tells us what goes where.

<pre>
<!-- nosyntax -->Start                              0.044s    0%
shakeArgsWith                      0.000s    0%
Function shake                     0.004s    0%
Database read                      0.021s    0%
With database                      0.002s    0%
Running rules                    101.917s   99%  =========================
Pool finished (32 threads, 4 max)  0.000s    0%
Lint checking                      0.081s    0%
Profile report                     0.062s    0%
Total                            102.131s  100%
</pre>

If the database is taking a long time, consider whether you are storing too much information in oracles.

Add `--timing` to see where the time is going.

It's worthwhile to check the database size, make sure its not too huge.


## Console output

If you print a line at the very beginning of your build script in main, how long does it take to show up?

You may want to tag especially expensive rules, and see how long they take.

You can capture time from a command with `Time t <-`, or using the `duration` function from Extra.

Debug tracing can sometimes help, specify `-VVV` on the command line to go to the maximum level of diagnostics.


<span class="target" id="html-profile"></span>

## HTML profile reports

Shake features an advanced profiling feature. To build with profiling run `build --report`, which will generate an interactive HTML profile named `report.html`. This report lets you examine what happened in that run, what takes most time to run, what rules depend on what etc. There is a help page included in the profiling output, and a [profiling tutorial/demo](https://cdn.rawgit.com/ndmitchell/shake/35fbe03c8d3bafeae17b58af89497ff3fdd54b22/html/demo.html).

To view profiling information for the _previous_ build, you can run `build --no-build --report`. This feature is useful if you have a build execution where a file unexpectedly rebuilds, you can generate a profiling report afterwards and see why. To generate a lightweight report (about 5 lines) printed to the console run `build --report=-`.

Given the time is in want, you may get more out of Shake profiling. Pass --profile=- to get a brief profile summary, and --profile=profile.html to generate a file listing what Shake is doing. Also doing --verbose (up to 3 times) will give you increasingly detailed levels of what Shake is doing. That should let you find out if something is running, or is paused and waiting.

You can also get all the raw information in JSON by specifying `--report=output.json`.

## Haskell profiling

generate a Haskell profile.

You can use the normal Haskell profiler

You may find that you get better profiling without -I0 - it's certainly a flag that has messed up profiling in some versions of GHC. Generally it makes Shake performance better to include it, but for profiling it doesn't matter too much.

## Chrome traces

Before 

Run `--profile=report.trace`. Navigate in your browser to `chrome://tracing/`.

![](profile-trace.png)
